\chapter{Generalization and Optimization}

Writing code for a specific case without flexibility is relatively easy; the implementation is brief and simple. On the other hand, creating a general solver for Quantum Mechanical systems involves several layers of complexity, such as different potentials, single particle bases, sampling models, etc., which may easily lead to a combinatoric disaster if the planning is not done right. 

This chapter will cover the underlaying assumptions and goals in Section \ref{sec:AssGoal}, the ..

\section{Underlaying Assumptions and Goals}
\label{sec:AssGoal}

The overall goal to achieve efficiency for a high number of degrees of freedom without sacrificing diversity and readability was heavily dependent on the planning process. Thousands of lines of code should be written once and for all\footnote{This, however, is rarely the case. The code used in this thesis has been completely restructured four times.}.

\subsection{Assumptions}
\label{sec:ass}

The optimizations scheme was laid down based on the following assumptions

\cfbox{3cm-3pt}{
\begin{enumerate}[label=\textbf{(\roman{*})}, ref=(\roman{*}), align=left]
 \item The constituents of the simulated systems are either pure fermionic or pure bosinic.
 \item A fermionic system is a two-level system\footnote{The actual code is developed to easily add support for $n$-level systems.}.
 \item The trial wave function of a fermionic system is a single determinant.
 \item A bosonic system is modeled by all particles being in the same assumed single particle ground state.
 \vspace{0.3cm}
\end{enumerate}
}

Other assumptions are done, such as the time-independence of the Hamiltonian, however, these arise due to the QMC solver, not the specific implementation, and are hence described in Chapter \ref{ch:QMC}.

\subsection{Generalization Goals}
\label{sec:genGoals}

The level of generalization is set to be at any combination of the following

\cfbox{3.17cm-1pt}{
\begin{enumerate}[label=\textbf{(\roman{*})}, ref=(\roman{*}), align=left]
 \item Fermions and Bosons.
 \item Anisotropic- and isotropic diffusion, i.e. Brute Force - or Importance sampling.
 \item Any choice of single particle basis, including expanded single particle bases.
 \item Any combination of any potentials.
 \vspace{0.2cm}
\end{enumerate}
}
 
In addition, the following generalizations are made in the solver

\cfbox{3.42cm-1pt}{
\begin{enumerate}[label=\textbf{(\roman{*})}, ref=(\roman{*}), align=left]
\setcounter{enumi}{4}
 \item Full numerical support for all values involving derivatives.
 \item Error estimation techniques implemented independent of solvers.
 \vspace{0.2cm}
\end{enumerate}
}


This ends up as a complex span of scenarios. The challenge is to, despite the numerous combinations, simplify the structure in a way that makes the code readable and easily expandable. If-testing inside the solver in order to achieve generalization are in other words out of the question (see the next section).

\subsection{Optimization Goals}
\label{sec:optGoals}

Designed for the CPU, runtime optimizations are favored over memory optimizations. The following list may appear short, but every step brings immense amounts of complexity to the implementation

\cfbox{3.6cm}{
\begin{enumerate}[label=\textbf{(\roman{*})}, ref=(\roman{*}), align=left]
 \item Identical values should never be re-calculated.
 \item Generalization should not be achieved through if-tests in repeated function calls, but rather through polymorphism (see Section \ref{sec:typeCastPoly}).
 \item Linear scaling of runtime and number of CPUs for large simulations.
 \vspace{0.2cm}
\end{enumerate}
}

\clearpage
\section{Specifics Regarding Generalization}

The implementation of methods are done using the concepts introduced in Chapter \ref{ch:SciProg}. Generalization is achieved through the use of deep object orientation, i.e. polymorphism, rather than if-testing. The assumptions listed in Section \ref{sec:ass} are applied if not otherwise stated.

For details regarding the implementation of methods, see the code in \cite{libBorealisCode}.

\cfbox{3.8cm}{
\begin{enumerate}[label=\textbf{(\roman{*})}, ref=(\roman{*}), align=left]
 \setcounter{enumi}{0}
 \item Fermions and Bosons.
\end{enumerate}
}

As discussed in Section \ref{sec:manyBodyWFs}, the only thing separating fermions and bosons is how the many-body wave function is constructed from the single-particle orbitals. In the case of fermions, the expression is given in terms of two determinants, while for bosons, it is simply the product of all states.

\begin{lstlisting}
double Fermions::get_spatial_wf(const Walker* walker) {
    using namespace arma;
    
    //Spin up times Spin down (determinants)
    return det(walker->phi(span(0, n2 - 1), span())) * det(walker->phi(span(n2, n_p - 1), span()));
}
\end{lstlisting}

\begin{lstlisting}
double Bosons::get_spatial_wf(const Walker* walker) {
    using namespace arma;
    
    //arma::diagmat flags the determiant to only multiply diagonal elements
    return det(diagmat(walker->phi));
}
\end{lstlisting}
